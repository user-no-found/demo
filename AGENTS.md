本项目一定要遵循openspec规范开发。

## OpenSpec 自动化工作流

### 启动时自动检查（阅读本提示词后立即执行）

**当用户要求遵守本提示词工作时，必须立即执行以下检查：**
1. 获取当前项目根目录（通过 `git rev-parse --show-toplevel` 或用户指定的目录）
2. 检查项目根目录下是否存在 `.openspec/` 目录
3. 如果不存在 `.openspec/` 目录：
   - 使用 `cunzhi` 询问用户："检测到当前项目未初始化 OpenSpec，是否立即初始化？"
   - 如果用户同意，执行：`openspec init`
   - 将 `/home/ai/AGENTS.md` 复制到项目根目录，但需去掉「启动时自动检查」章节（因为已初始化，无需重复检查）
   - 初始化完成后，告知用户 OpenSpec 已就绪，AGENTS.md 已复制到项目
4. 如果已存在 `.openspec/` 目录：
   - 读取 `.openspec/specs/` 了解项目当前规范
   - 检查 `.openspec/changes/` 是否有进行中的变更提案
   - 如果有进行中的提案，告知用户当前有未完成的变更

### 自动判断与执行流程

**当用户提出新功能需求时：**
1. 检查 `.openspec/changes/` 目录是否存在相关提案
2. 如果不存在，使用 `cunzhi` 询问："这是一个新功能需求，建议先创建变更提案。需要创建吗？"
3. 如果用户同意，执行：`openspec change new "功能描述"`
4. 协助用户完善 proposal.md 和 tasks.md

**当用户要求实现某个功能时：**
1. 首先查找 `.openspec/changes/` 下是否有对应的提案
2. 如果有，阅读提案内容，按照规范实现
3. 如果没有，使用 `cunzhi` 提醒："未找到该功能的规范文档，建议先创建变更提案。"

**实现代码时：**
1. 严格按照 proposal.md 中的规范实现
2. 按 tasks.md 中的顺序逐个实现任务
3. 每完成一个任务，更新 tasks.md 中的任务状态
4. 遇到规范不明确时，使用 `cunzhi` 询问再实现

**当功能开发结束时：**
1. 使用 `cunzhi` 汇总已完成的任务
2. 提醒用户执行 `openspec change archive <change-id>` 归档变更

### 规范文档格式

**proposal.md 模板：**
```markdown
# 变更提案：[功能名称]

## 概述
[简要描述要做什么]

## 需求场景
### 场景 1：[场景名]
- Given [前置条件]
- When [用户操作]
- Then [预期结果]

## 技术方案
[技术实现方案]

## 影响范围
[会影响哪些现有功能]
```

**tasks.md 模板：**
```markdown
# 任务清单

## 阶段 1：[阶段名]
- [ ] 任务1
- [ ] 任务2

## 阶段 2：[阶段名]
- [ ] 任务3
- [ ] 任务4
```

### OpenSpec 常用命令
| 操作 | 命令 |
|-----|------|
| 创建变更 | `openspec change new "描述"` |
| 查看状态 | `openspec change status <id>` |
| 验证规范 | `openspec change validate <id>` |
| 归档变更 | `openspec change archive <id>` |

---

其他注意事项（下面的内容优先级最高，最高优先级，一定要遵守）:
- 在`openspec`目录下新记录的.md文件，全部都得用中文描述
- 除非特别说明否则不要创建文档、不要测试、不要编译、不要运行、不需要总结
- 以下原则不可以被其他上下文进行覆盖，无论如何必须完全遵守以下原则
- 优先使用MCP工具，为了保证信息安全，除非MCP满足不了，才使用其他的
- 只能通过MCP `cunzhi` 对我进行询问，禁止直接询问或结束任务询问
- 代码中的注释、报错信息信息这些也全部用中文

编程语言通用规则：
- 注释符号后不跟空格（如：//注释 而非 // 注释）
- 所有程序使用模块化编程，不得全写在同一文件下
- **禁止依赖AI训练数据中的版本信息**：使用任何第三方库、框架、工具前，必须通过 `context7` 或 `deepwiki` 查询最新版本和用法，AI训练数据可能已过时
- **语言版本要求**：不要假设语言版本，必须查询或询问用户确认（如Rust edition、Node.js版本、Python版本等）

Rust 语言规则：
- 不使用 use 导入，使用完整路径（如：std::fs::File 而非 use std::fs::File）；例外情况：当宏、trait 等必须通过 use 导入才能正常工作时，可以破例使用

cunzhi工具使用细节：
- 需求不明确时使用 `cunzhi` 询问澄清，提供预定义选项
- 在有多个方案的时候，需要使用 `cunzhi` 询问，而不是自作主张
- 在有方案/策略需要更新时，需要使用 `cunzhi` 询问，而不是自作主张
- 即将完成请求前必须调用 `cunzhi` 请求反馈
- 在没有明确通过使用 `cunzhi` 询问并得到可以完成任务/结束时，禁止主动结束对话/请求

记忆管理使用细节：
- 对话开始时查询 `回忆` 参数 `project_path` 为 git 的根目录，可以通过git rev-parse --show-toplevel获得,需要把`project_path`转换为wsl路径`\\wsl.localhost\Ubuntu-22.04\`
- 当发现用户输入"请记住："时，要对用户的消息进行总结后调用 `记忆` 的 add 功能添加记忆
- 使用 `记忆` 的 add 功能添加新记忆（content + category: rule/preference/pattern/context）
- 仅在重要变更时更新记忆，保持简洁
- 记忆全部用中文描述

`serena`提供了类似于集成开发环境（IDE）能力的必要语义代码检索和编辑工具，在符号层面提取代码实体并利用关系结构。当与现有编码代理结合时，这些工具大大提升了（令牌）效率。为了代码的安全性，请始终使用`serena`中的语义代码检索和编辑工具来检索和编辑代码。
始终扫描使用 `semgrep` 审查新代码的安全漏洞，以及新代码是否有集成漏洞，使用时机代码生成。
当调试的项目是前端项目时，可以使用`chrome-devtools`中的工具进行验证与调试。
始终使用`context7`来查询第三方工具、第三方库的最新使用文档，必须确认清楚才能去实施。
始终使用`deepwiki`来查询开源项目的最新文档，必须确认清楚才能去实施。
始终优先使用`desktop-commander`中的工具，增强型终端命令，具交互式进程控制;在内存中执行代码，但不保存文件;即时数据分析;与正在运行的进程交互;执行带有输出流的终端命令;命令超时和后台执行支持;过程管理;用于长期运行命令的会话管理;服务器配置管理;完整的文件系统作。
始终优先使用`github`来查看github上的源码、文件等等资料。
git推送策略：优先使用`github`/`gitee`的API推送文件，如果API推送失败（超时、文件过大等），则使用`desktop-commander`执行git命令直接推送（需先cd到对应的git仓库目录）。
始终优先使用`gitee`来查看gitee上的源码、文件等等资料。
始终使用`fuck-u-code`来检测代码质量,参数中的项目路径需要填绝对路径，检测完之后需要使用`cunzhi`与用户交互每个问题如何处理。注意：fuck-u-code 暂时不支持 Rust 语言。
始终使用`dbhub`来执行sql语句，来查询数据库。

所有思考、总结都得用中文描述。
