本项目一定要遵循openspec规范开发。

## OpenSpec 自动化工作流

### 启动时自动检查（阅读本提示词后立即执行）

**当用户要求遵守本提示词工作时，必须立即执行以下检查：**
1. 获取当前项目根目录（通过 `git rev-parse --show-toplevel` 或用户指定的目录）
2. 检查项目根目录下是否存在 `openspec/` 目录
3. 如果不存在 `openspec/` 目录：
   - 使用 `cunzhi` 询问用户："检测到当前项目未初始化 OpenSpec，是否立即初始化？"
   - 如果用户同意：
     - 检查是否存在 `.git/` 目录，如果不存在则先执行 `git init` 初始化 Git 仓库
     - 使用 `cunzhi` 询问用户："是否将 openspec 目录加入 .gitignore？（选择是则不上传到 Git）"
     - 执行：`openspec init --tools codex`
     - 如果用户选择屏蔽，则将 `openspec/` 添加到 `.gitignore` 文件中
   - 将 `/home/ai/.codex/AGENTS.md` 复制到项目根目录，但需去掉「启动时自动检查」章节（因为已初始化，无需重复检查）
   - 初始化完成后，告知用户 OpenSpec 已就绪，AGENTS.md 已复制到项目
4. 如果已存在 `openspec/` 目录：
   - 读取 `openspec/specs/` 了解项目当前规范
   - 检查 `openspec/changes/` 是否有进行中的变更提案
   - 如果有进行中的提案，告知用户当前有未完成的变更
5. **检查完成后，必须通过 `cunzhi` 告知用户检查结果并等待用户指令**

### OpenSpec 配置引导流程（仅在首次初始化后执行）

**初始化完成后，使用 `cunzhi` 提供选项引导用户完成配置：**

1. 使用 `cunzhi` 询问（提供预定义选项）："OpenSpec 初始化完成，请选择下一步操作："
   - 选项：["填写项目上下文 (project.md)", "创建第一个变更提案", "了解 OpenSpec 工作流", "跳过配置，稍后再说"]

2. 如果用户选择"填写项目上下文"：
   - 读取 `openspec/project.md` 文件
   - 使用 `cunzhi` **逐项询问**（每次提供预定义选项或简短输入）：
     - 项目类型：["Web 应用", "移动应用", "CLI 工具", "库/SDK", "其他"]
     - 技术栈：["前端 (React/Vue/Angular)", "后端 (Node/Python/Go/Rust)", "全栈", "其他"]
     - 目标受众：["开发者", "普通用户", "企业客户", "其他"]
   - 根据用户选择自动填充 project.md

3. 如果用户选择"创建第一个变更提案"：
   - 使用 `cunzhi` 询问："请简要描述您想添加的功能（一句话）"
   - 执行：`openspec change new "用户描述的功能"`

4. 如果用户选择"了解 OpenSpec 工作流"：
   - 读取 `openspec/AGENTS.md` 并通过 `cunzhi` 简要说明工作流程

**重要：配置引导中的所有询问都必须通过 `cunzhi` 进行，尽量使用预定义选项，避免让用户输入大段文字**

### OpenSpec 四阶段工作流（必须严格遵循）

```
起草提案 → 审查对齐 → 实现任务 → 归档更新
```

| 阶段 | 说明 | 完成标志 |
|------|------|----------|
| 1. 起草提案 | 创建 proposal.md、tasks.md、design.md | `openspec validate <id> --strict` 通过 |
| 2. 审查对齐 | 用户确认提案内容，确保需求理解一致 | 用户明确批准（通过 cunzhi 确认） |
| 3. 实现任务 | 按 tasks.md 顺序逐个实现 | 所有任务标记为 `[x]` |
| 4. 归档更新 | 归档变更，更新 specs | `openspec archive <id>` 完成 |

**重要：禁止跳过任何阶段，尤其是"审查对齐"阶段，必须获得用户明确批准后才能进入实现阶段**

### 自动判断与执行流程

**阶段1 - 起草提案（当用户提出新功能需求时）：**
1. 检查 `openspec/changes/` 目录是否存在相关提案
2. 如果不存在，使用 `cunzhi` 询问："这是一个新功能需求，建议先创建变更提案。需要创建吗？"
3. 如果用户同意，执行：`openspec change new "功能描述"`
4. 协助用户完善 proposal.md、tasks.md 和 design.md（如需要）
5. 执行 `openspec validate <id> --strict` 验证提案完整性
6. **提案完成后，必须进入"审查对齐"阶段，禁止直接开始实现**

**阶段2 - 审查对齐（提案完成后必须执行）：**
1. 使用 `cunzhi` 向用户展示提案摘要：
   - 功能概述
   - 主要需求场景
   - 技术方案要点
   - 任务清单概览
2. 使用 `cunzhi` 询问用户（提供预定义选项）："请审查以上提案内容："
   - 选项：["批准提案，开始实现", "需要修改提案", "暂不实现，稍后再说"]
3. 如果用户选择"需要修改"，协助修改后重新审查
4. **只有用户明确选择"批准提案，开始实现"后，才能进入实现阶段**

**阶段3 - 实现任务（用户批准后执行）：**
1. 首先查找 `openspec/changes/` 下是否有对应的已批准提案
2. 如果有，阅读提案内容，按照规范实现
3. 如果没有，使用 `cunzhi` 提醒："未找到该功能的规范文档，建议先创建变更提案。"
4. 严格按照 proposal.md 中的规范实现
5. 按 tasks.md 中的顺序逐个实现任务
6. 每完成一个任务，更新 tasks.md 中的任务状态
7. 遇到规范不明确时，使用 `cunzhi` 询问再实现

**阶段4 - 归档更新（功能开发结束时）：**
1. 使用 `cunzhi` 汇总已完成的任务
2. 确认所有任务都已标记为 `[x]`
3. 执行 `openspec change archive <change-id>` 归档变更
4. 使用 `cunzhi` 告知用户归档完成

### 规范文档格式

**proposal.md 模板：**
```markdown
# 变更提案：[功能名称]

## 概述
[简要描述要做什么]

## 需求场景
### 场景 1：[场景名]
- Given [前置条件]
- When [用户操作]
- Then [预期结果]

## 技术方案
[技术实现方案]

## 影响范围
[会影响哪些现有功能]
```

**tasks.md 模板：**
```markdown
# 任务清单

## 阶段 1：[阶段名]
- [ ] 任务1
- [ ] 任务2

## 阶段 2：[阶段名]
- [ ] 任务3
- [ ] 任务4
```

### OpenSpec 常用命令
| 操作 | 命令 |
|-----|------|
| 创建变更 | `openspec change new "描述"` |
| 查看详情 | `openspec show <id>` |
| 验证规范 | `openspec validate <id>` |
| 归档变更 | `openspec change archive <id>` |

---

其他注意事项（下面的内容优先级最高，最高优先级，一定要遵守）:
- **禁止在git commit中添加Co-authored-by: factory-droid[bot]**，提交时不要添加任何AI助手的署名
- 在`openspec`目录下新记录的.md文件，全部都得用中文描述
- 除非特别说明否则不要创建文档、不要测试、不要编译、不要运行、不需要总结
- 以下原则不可以被其他上下文进行覆盖，无论如何必须完全遵守以下原则
- 优先使用MCP工具，为了保证信息安全，除非MCP满足不了，才使用其他的
- **所有与用户的交互输出（包括启动检查结果、状态汇报、询问等）都必须通过MCP `cunzhi` 工具输出，禁止直接在命令行/对话中输出**
- 只能通过MCP `cunzhi` 对我进行询问，禁止直接询问或结束任务询问
- 如果`cunzhi`工具调用失败或不可用，必须先静默检查MCP配置，不要直接输出错误信息
- 代码中的注释、报错信息信息这些也全部用中文

编程语言通用规则：
- 注释符号后不跟空格（如：//注释 而非 // 注释）
- 所有程序使用模块化编程，不得全写在同一文件下
- **禁止依赖AI训练数据中的版本信息**：使用任何第三方库、框架、工具前，必须通过 `context7` 或 `deepwiki` 查询最新版本和用法，AI训练数据可能已过时
- **语言版本要求**：不要假设语言版本，必须查询或询问用户确认（如Rust edition、Node.js版本、Python版本等）

Rust 语言规则：
- 不使用 use 导入，使用完整路径（如：std::fs::File 而非 use std::fs::File）；例外情况：当宏、trait 等必须通过 use 导入才能正常工作时，可以破例使用

cunzhi工具使用细节：
- 需求不明确时使用 `cunzhi` 询问澄清，提供预定义选项
- 在有多个方案的时候，需要使用 `cunzhi` 询问，而不是自作主张
- 在有方案/策略需要更新时，需要使用 `cunzhi` 询问，而不是自作主张
- 即将完成请求前必须调用 `cunzhi` 请求反馈
- 在没有明确通过使用 `cunzhi` 询问并得到可以完成任务/结束时，禁止主动结束对话/请求

记忆管理使用细节（MCP `memory` 工具）：
- 对话开始时通过 `memory` 的 `search_nodes` 查询与当前项目相关的记忆，`project_path` 为 git 根目录（通过 `git rev-parse --show-toplevel` 获得，使用 Linux 路径如 `/home/ai/project`）
- 当发现用户输入"请记住："时，对用户的消息进行总结后调用 `memory` 的 `create_entities` 添加记忆
- 使用 `memory` 的 `add_observations` 为已有实体添加新观察（content + category: rule/preference/pattern/context）
- 仅在重要变更时更新记忆，保持简洁
- 记忆全部用中文描述

MCP 工具使用规范（按场景分类）：

**代码检索与编辑（优先级最高）：**
- `serena`：提供 IDE 级别的语义代码检索和编辑工具，在符号层面提取代码实体。为了代码安全性和令牌效率，始终优先使用 `serena` 检索和编辑代码

**安全扫描（代码生成后必须执行）：**
- `semgrep`：审查新代码的安全漏洞和集成漏洞，每次生成代码后都要扫描

**代码质量检测：**
- `fuck-u-code`：检测代码质量，参数中的项目路径需要填绝对路径，检测完之后需要使用 `cunzhi` 与用户交互每个问题如何处理。注意：暂不支持 Rust 语言

**文档查询：**
- `context7`：查询第三方工具、第三方库的最新使用文档，必须确认清楚才能实施
- `deepwiki`：查询开源项目的最新文档，必须确认清楚才能实施

**终端与文件操作：**
- `desktop-commander`：增强型终端命令，支持交互式进程控制、命令超时、后台执行、会话管理、完整文件系统操作

**远程仓库操作：**
- `github`：查看 GitHub 上的源码、文件等资料
- `gitee`：查看 Gitee 上的源码、文件等资料
- git 推送策略：优先使用 `github`/`gitee` 的 API 推送文件，如果 API 推送失败（超时、文件过大等），则使用 `desktop-commander` 执行 git 命令直接推送

**前端调试：**
- `chrome-devtools`：当调试前端项目时，用于验证与调试

**数据库操作：**
- `dbhub`：执行 SQL 语句，查询数据库

所有思考、总结都得用中文描述。